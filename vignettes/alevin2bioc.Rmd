---
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_depth: 3
    fig_width: 5
bibliography: "`r file.path(system.file(package='alevin2bioc', 'vignettes'), 'library.bib')`"
vignette: >
  %\VignetteIndexEntry{alevin2bioc}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding[utf8]{inputenc}
---

# Importing alevin scRNA-seq counts into R/Bioconductor

## Instructor(s) name(s) and contact information

[Michael Love](https://mikelove.github.io),
[Avi Srivastava](https://k3yavi.github.io)


```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(cache=TRUE)
```

## Introduction

*alevin* is a fast end-to-end pipeline to process droplet-based single-cell RNA sequencing data, which generates per-cell gene count estimation by performing cell barcode detection, read mapping, unique molecular identifier (UMI) deduplication.[@alevin]. It extends the methods in the
*Salmon* software [@salmon].

The data we will use is generated from the Peripheral blood mononuclear cells (PBMCs) of a healthy donor which has been sequenced & made public by 10x Genomics (referred as PBMC_1k V2 Chemistry) [@pbmc].

## Running alevin

In order to run *alevin*, we must first generate some metadata. The step-by-step guidenline to process the reference sequence and generate the required data can be found [here](https://combine-lab.github.io/alevin-tutorial/2018/setting-up-resources/).

Instructions on indexing a set of reference transcripts can be found
[here](https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/). 
For this experiment, we used the 
[GENCODE](https://www.gencodegenes.org/) 
human reference transcripts [@gencode].

## Importing alevin data with tximeta

We will use *tximeta* to import the *alevin* counts into
R/Bioconductor. The main function `tximeta` reads information from the
entire output directory of *alevin* or *Salmon* in order to
automatically detect and download metadata about the reference
sequences (the transcripts) [@tximeta]. It should work "out of the
box" for human, mouse, and fruit fly reference transcripts from
GENCODE, Ensembl, or RefSeq

First we specify the path where the quantification data is stored. In
this tutorial, the data is stored in an R package, so we need to use
the `system.file` command. 

**Note:** For typical use, you would not use `system.file`, but would
just specify the path to the directory of the output from *alevin*.

**Second note:** when sharing *alevin* or *Salmon* datasets, make sure
to share the entire output directory (you can `zip` or `tar` the
directories to make them into a single share-able file).

```{r}
# normally you just would use:
# dir <- "/path/to/alevin/output"
extdata <- system.file("extdata", package="alevin2bioc")
dir <- file.path(extdata, "pbmc_1k")
```

We make a vector called `files` (for *alevin* this will point to just
a single file, but with *Salmon* usually one would import multiple
files at a time).

```{r}
files <- file.path(dir, "alevin", "quants_mat.gz")
file.exists(files)
```

```{r echo=FALSE}
suppressPackageStartupMessages(library(GenomicFeatures))
```

We can import the *alevin* quantification using the following call to
`tximeta`. The extra argument to *alevin* will filter out cells based
on *alevin*'s post-quantification quality control methods (see paper
for details).

```{r}
library(tximeta)
se <- tximeta(files, type="alevin", alevinArgs=list(filterBarcodes=TRUE))
```

We can see as it was importing that it automatically detected we are
working with data quantified using GENCODE's *Homo sapiens* reference
transcripts, release 33. The transcript metadata was added
programmatically to the output (this object, `se`). `tximeta` is also
written in such a way that it will avoid unnecessary downloads and
parsing of files -- it will first attempt to find a cached version of
the metadata, to avoid re-downloading or re-parsing these files.

`tximeta` returns a *SummarizedExperiment* [@Lawrence2013]. We can
easily convert this object into a *SingleCellExperiment*
[@Amezquita2020] which has specific slots designed for single-cell
experiment data.

```{r}
suppressPackageStartupMessages(library(SingleCellExperiment))
sce <- as(se, "SingleCellExperiment")
```

The *SingleCellExperiment* object is used widely across Bioconductor
packages (as you may already know), and so the code up to this point
can be used as an entry point into other Bioconductor single cell
workflows. For more details on working with *SingleCellExperiment*
objects, one can consult the following online book: 
[Orchestrating Single-Cell Analysis with Bioconductor](https://osca.bioconductor.org/)
[@Amezquita2020].

## Benefits of tximeta

We can automatically add IDs, because *tximeta* knows the type of
identifiers on the rows of the `sce` object:

```{r}
library(org.Hs.eg.db)
sce <- addIds(sce, "SYMBOL")
```

```{r}
mcols(sce)
```

Also, because the provenance was detected, we also have the ranges of
the genes in their proper genomic context. So it is easy to find, for
example, genes near a particular position in the genome, in this case
4 genes that overlap the range `chr1:10,000,000-10,100,000`.

```{r}
x <- GRanges("chr1", IRanges(10e6,10.1e6))
sce[sce %over% x,]
```

## Add cell annotations

Cell annotations were already generated using *Seurat* [@seurat]. The
script is saved in this package in `inst/scripts/seurat.R`. Here we
will use them for size factor estimation and for visualization.

```{r}
ids <- readRDS(file.path(extdata, "idents.rds"))
top10 <- read.csv(file.path(extdata, "top10.csv"))
```

We subset to the cells that we have IDs for, and attach the labels in
the correct order:

```{r}
idx <- colnames(sce) %in% names(ids)
table(idx)
sce <- sce[,idx]
sce$cluster <- ids[colnames(sce)]
```

The number of cells per cluster:

```{r}
table(sce$cluster)
```

Note that the different clusters have different total counts, for
example:

```{r}
cs <- colSums(assays(sce)[["counts"]])
# cells with higher number of UMI
more.umi <- cs > 10000
(tab <- table(more.umi, sce$cluster))
100 * round(prop.table(tab,2),2) # percent
# cell with lower number of UMI
fewer.umi <- cs < 5000
(tab <- table(fewer.umi, sce$cluster))
100 * round(prop.table(tab,2),2) # percent
```

We have a data.frame with the top marker genes per cluster, as
identified with *Seurat*.

```{r}
head(top10)
```

## Plotting counts with uncertainty

In this section, we will begin to plot the counts for cells, for
specific genes, and showing the *inferential uncertainty* as
quantified by *alevin*. This is a unique aspect to the *alevin*
quantification method, that it retains gene multi-mapping reads,
instead of discarding these reads. *alevin* can also attach a measure
of uncertainty to each count in the matrix. *alevin* computes the mean
and variance of *inferential replicates* which are generated by
bootstrapping the read data. `tximeta` will import these inferential
mean and variance matrices by default (they are also sparse, similar
to the counts matrix).

We will first visualize the uncertainty, and later give an
example of a set of genes where the uncertainty is indicating
significant quantification uncertainty which is useful to consider
when performing EDA (exploratory data analysis) or statistical
analysis.

For a later demonstration of scaling, we will sort the cells by the
total count (this is not something you would necessarily do in a
typical analysis).

```{r}
o <- order(colSums(assays(sce)[["counts"]]), decreasing=TRUE)
sce <- sce[,o]
```

We can now use a plotting function `plotInfReps` from the *fishpond*
package in order to plot the inferential mean and variance for the
cells, for various genes.

```{r plot-basic}
library(fishpond)
plotInfReps(sce, idx="ENSG00000167286.9",
            x="cluster", mainCol="SYMBOL",
            legend=TRUE)
```

Here, we have `x` as a grouping variable for coloring the points, one
can also specify `x` to be a continuous covariate,
e.g. pseudo-time. An additional covariate `cov` can be used for
additional grouping, e.g. batches, donors or lineages.

Here we show the same plot but now subsetting the number of cells: 

```{r plot-medium}
idx <- sample(ncol(sce),200)
plotInfReps(sce[,idx],
            idx="ENSG00000167286.9",
            x="cluster", mainCol="SYMBOL",
            legend=TRUE)
```

This time only 100 cells:

```{r plot-small}
idx <- sample(ncol(sce),100)
plotInfReps(sce[,idx],
            idx="ENSG00000167286.9",
            x="cluster", mainCol="SYMBOL",
            legend=TRUE)
```

The plots change their features across different sample sizes for ease
of viewing the uncertainty of quantification for individual cells.

We can also choose to plot the cells in their original order (the
default for scRNA-seq is to sort by the mean value):

```{r plot-no-order}
plotInfReps(sce, idx="ENSG00000167286.9",
            x="cluster", mainCol="SYMBOL",
            reorder=FALSE)
```

## Scaling with size factors

We use `computeSumFactors` [@Lun2016] from the *scran* package
[@scran] to compute size factors that are stored in
`sizeFactors(sce)`. 

```{r size-factors}
library(scran)
sce <- computeSumFactors(sce, clusters=sce$cluster)
plot(cs, sizeFactors(sce), xlab="column sum", ylab="sum factor")
```

Now we demonstrate un-scaled counts and counts scaling with size 
factors just computed. (Note in the second plot that the first cell in
each group isn't the highest anymore.)

```{r scaling}
par(mfrow=c(2,1), mar=c(2.5,4.5,1,1))
plotInfReps(sce, idx="ENSG00000167286.9",
            x="cluster", main="",
            reorder=FALSE)
plotInfReps(sce, idx="ENSG00000167286.9",
            x="cluster", main="",
            applySF=TRUE, reorder=FALSE)
```

## Inferential variance (uncertainty)

In this second to last section, we will briefly talk about how the
inferential uncertainty as stored in the variance assay may be useful
in practice.

Many users may prefer to just work with the counts matrix, and not
consider the inferential mean and variance. We have found that,
globally, this may not lead to too much of a problem, but for certain
genes, it may be important to use the inferential variance in cases
where it may signal difficult to quantify genes. Inferential
uncertainty for bulk and single cell RNA-seq differential expression
was a focus of the *Swish* nonparametric statistical method [@swish]
which we do not demonstrate here, but one can refer to
the vignette of [swish](https://bioconductor.org/packages/swish) for
more details (in particular the section on *alevin* data).

Let's start by visualizing the uncertainty across all values in the
matrix: 


## References
